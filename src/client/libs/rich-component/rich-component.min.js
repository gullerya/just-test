const t="template",e="htmlUrl",n=Symbol("attach.light.dom"),o={};class r extends HTMLElement{constructor(){super();const t=this.getTemplate();t?"light"===this.constructor.domType?this[n]=t:this.attachShadow({mode:"open"}).appendChild(t):console.error(`failed to get template for ${this.localName}`)}connectedCallback(){n in this&&(this.appendChild(this[n]),delete this[n])}getTemplate(){let t=null;const e=o[this.localName];if("function"==typeof e){const n=e.call(this,this);n&&"TEMPLATE"===n.nodeName&&(t=n.content.cloneNode(!0))}else t=e.content.cloneNode(!0);return t}}export{r as ComponentBase,i as initComponent,a as fetchTemplate};async function i(n,i){let l;if(function(t){if(!t||"string"!=typeof t||!/^[a-z0-9]+(-[a-z0-9]+)*-[a-z0-9]+$/.test(t))throw new Error(`invalid element's tag/name: ${t}`);if(customElements.get(t))throw new Error(`'${t}' element already defined`)}(n),function(n,o){if(!(o&&o.prototype instanceof r))throw new Error(`invalid class for '${n}'; MUST NOT be null and MUST be an instance of ComponentBase`);if(!(t in o)&&!(e in o)||t in o&&e in o)throw new Error(`'${n}' MUST implement either static getter of '${e}' property returning component's HTML path, or static getter of '${t}' property returning a template`)}(n,i),t in i){if((!(l=i[t])||"TEMPLATE"!==l.nodeName)&&"function"!=typeof l)throw new Error(`'${n}' provided invalid template: ${l}`)}else{const t=i[e];if(!t||"string"!=typeof t)throw new Error(`'${n}' provided invalid HTML URL: ${t}`);const o=await a(t);if(!o)throw new Error(`failed to init template of '${n}' from '${t}'`);(l=document.createElement("template")).innerHTML=o}o[n]=l,customElements.define(n,i)}async function a(t){if(!t||"string"!=typeof t)throw new Error(`invalid HTML template URL: ${t}`);let e=null;const n=await fetch(t);if(n.ok){const o=await n.text();o?e=o:console.error(`failed to fetch HTML template from '${t}', no content`)}else console.error(`failed to fetch HTML template from '${t}', status ${n.status}`);return e}